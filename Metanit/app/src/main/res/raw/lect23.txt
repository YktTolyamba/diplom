<style>h3 {margin-bottom: -15px; }</style><center><h3>11. Рекурсия</h3></center>
Рекурсия бывает прямая и косвенная.
Рекурсия называется прямой, если функция вызывает сама себя.
Рекурсия называется косвенной, если функция вызывает сама себя по
средствам другой функции.
Если функция вызывает себя, в стеке создается копия значений ее
параметров, как и при вызове обычной функции. При повторном вызове этот
процесс повторяется. При завершении функции соответствующая часть стека
освобождается, и управление передается вызывающей функции, выполнение
которой продолжается с точки, следующей за рекурсивным вызовом.
Обычно к рекурсивным алгоритмам приводятся рекуррентные соотношения.
Пример1:
Вычисление факториала.
fn=n!;
fn-1=(n-1)!
Чтобы получить рекуррентное соотношение делим:
; 1
( 1)!
!
1 0 1
1
     

 

n f n f f f
n
n
f
f
n n
n
n
#include <iostream.h>
int f(int n)
{ if (n==0||n==1) return 1;
else return(n*f(n-1));
}
void main()
{int n;
cout<<”n=” ; cin>>n;
cout<<”n!=”<<f(n)<<endl;
}
2
пусть n=3
рассмотрим как работает программа:
n!= ↓ f(3) ↑
↓ 3*f(2) ↑ 3*2*1
↓ 2*f(1) ↑ 2*1
↓ 1 ↑
Все время «заходит» вглубь, потом идет обратно (возвращается).
Упражнение 1: Вычислить сумму Sn=1+2+3+…+n
 Sn-1=1+2+3+…+(n-1)
 Sn= Sn-1+n
 S0=0
int S(int n)
{ if (n==0) return 0;
 else return (S(n-1)+n);
}
Пример2: Написать рекурсивную функцию вычисления членов
последовательности Фибоначчи.
1 1 2
1 2
 
   
f f
f f f
n n n
#include <iostream.h>
int f(int n)
{ if (n==1||n==2) return 1;
 else return (f(n-1)+f(n-2));
}
…
3
Посмотрим как эта программа работает.
f(5)=5
 3 2
f(4) + f(3)
 2 1 1 1
f(3) + f(2) f(2) + f(1)
 || || ||
f(2)+f(1) 1 1 1
|| ||
 1 1
Пример1 работал линейно и обратно
Пример2 раздваивается как бинарное дерево и обратно
Пример3: Написать рекурсивную функцию определения НОД двух a, b.
НОД(a,b). (рассмотреть до тех пор, пока один из них будет равен 0)
int NOD(int a, int b)
{ if (a==0||b==0) return (a+b); // так как один из них равен 0 и мы не знаем
какой.
else if (a>b) return NOD(a-b,b);
else return NOD(a,b-a);
}
a=8, b=12
NOD(8,12) = 4
 NOD(8,4)=4
 NOD(4,4)=4
 NOD(4,0)=4
Упражнение2: Написать рекурсивную функцию x
k
.
pk=x
k
=x
k-
1*x
4
pk=pk-1*x
p0=1
float p(int k, float x)
{ if (k==0) return 1;
else return (x*p(k-1,x));
}
стандартная функция pow(x,k) (она тоже явл-ся рекурентной)
int pow(int x, int k)
{ if (k==0) return 1;
 else return (x*pow(x,k-1));
}
Пример4: Дано целое число n>0. Найти сумму цифр.
#include <iostream.h>
void sum (long n, long&s) // получаем результат через адрес переменной s.
{ if (n==0) s=0;
 else sum(n/10,s);
 s=s+n%10;
}
void main()
{ long n, s;
cout<<”n=”; cin>>n; sum(n,s);
cout<<”s=”<<s<<’\n’;
n=123
sum(123,s) s=1+2+3=6
 sum(12,s) s=1+2
 sum(1,s) s=0+1
 sum(0,s) s=0
Когда из функции выходит, тогда происходит суммирование.
Такой прием (функция) хорошо используется для печати стеков и т.п., при
суммировании с начала.
5
Пример5: Написать рекурсивную функцию перевода целого числа из 10 с.с. в
2 с.с.
17=1*24
+0*23
+0*22
+0*21
+1*20
100012=17
#include <iostream.h>
void dectobin (long n)
{ if (n>1) dectobin(n/2);
cout<<n%2;
}
void main()
{long n;
cout<<”n=”; cin>>n;
dectobin(n);
}
n=4=1002
dectobin(4) 100 // печатает 0
dectobin(2) 10 // печатает 0
dectobin(2) 1 // печатает 1
Пример6: Дан одномерный массив. Написать рекурсивную функцию
определения максимального значения.
#include <iostream.h>
int a[5]={100, 20, 300, 4, 500};
void max(int n, int &x)
{ if (n==0) x=a[0]; else max(n-1, x);
 if (a[n]>x) x=a[n];
}
void main()
{int x;
6
max(4,x);
cout<<”max=”<<x;
}
Пример7: Метод быстрой сортировки.
Процедура делит массив на 2 части. В левую помещаются элементы меньше,
чем элемент, выбранный в качестве среднего, а в правой – больше.
#include <iostream.h>
void vvod (float a[], const int n);
void qsort (floata[], int left, int right);
void vyvod(float a[], const int n);
void main()
{ const int n=10; // или n=11
float a[n];
int i, l ,k;
l=0; k=n-1 //или l=1, k=n левая и правая границы начального фрагмента
vvod(a,n);
qsort(a,l,k);
vyvod(a,n);
}
void vvod(float a[], const int n)
{ int i;
foi(i=0; i<=n; i++)
cin>>a[i];
}
void qsort (float a[], int left, int right)
{ int i=left, j=right;
float middle=a[(left+right)/2];
float temp;
while (i<j)
{ while (a[i]<middle) i++;
7
while (middle<a[j]) j--;
if (i<=j) {temp=a[i]; a[i]=a[j]; a[j]=temp; i++, j--;}
}
if (left<j) qsort (a,left, j); // сортировка левой половинки
if (i<right) qsort(a,i,right); // сортировка правой половинки
}
void vyvod(float a[], const int n)
{ int i;
for(i=0; i<n; i++)
cout<<a[i]<<”_”;}