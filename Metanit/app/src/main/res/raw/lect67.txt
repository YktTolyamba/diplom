<style>h3 {margin-bottom: -15px; }</style><center><h3>5. Программы циклической структуры</h3></center>
5.1. Оператор цикла с предусловием while
Цикл с предусловием обычно используется для программирования
процессов, в которых число повторений оператора цикла не известно, а
задается некоторое условие его окончания. Он имеет вид:
while (<логическое выражение>) <оператор>
Выполнение оператора цикла с предусловием начинается с проверки
истинности (выполнения) <логического выражения>, записанного
после слова while. Если оно истинно, то выполняется <оператор>, а затем
вновь проверяется условие и т.д. Как только на очередном шаге окажется,
что условие не истинно, то выполнение <оператора> прекратится.
Примеры
1) k=0;
 while (n>0)
 { n=n/10; k=k+1; }
2) i=0; s=0;
 while (i<100) { i++; s=s+pow(I,2); }
3) x=0; y=0;
 while (x*x+y*y<4)
 { x=rand(); y=random(100); }
Примеры программ
1. Дано целое положительное число n (n<109
). Является ли заданное число
палиндромом, т.е. числом которое читается одинаково слева направо и справа
налево? Например, палиндромами являются числа 797, 2002, 123321.
Обсуждение. Для проверки поставленной задачи необходимо записать
цифры данного числа в обратном порядке (получить число “перевертыш”) и
сравнить с исходным числом. Если они равны, то исходное число является
палиндромом. “Перевертыш” строится последовательным выделением цифр
с конца (a=r%10; r:=r/10) и образованием нового числа по формуле:
M=M*10+a. Здесь переменная a пробегает все цифры исходного числа с
конца.
#include <stdio.h>;
void main()
{ unsigned long N, M, r, a;
 printf("N="); scanf("%li",&N);
 r=N; M=0;
 while (r>0)
 {
 a=r%10;
 M=M*10+a; //получение "перевертыша"
 r=r/10; //отбрасывание последней цифры
 }
 if (N==M) printf("Палиндром");
 else printf("Не палиндром");
}
2. Алгоритм Евклида. Даны два неотрицательных числа a и b одновременно
не равные нулю. Найти наибольший общий делитель.
Обсуждение. Пусть a≥b и r остаток от деления a на b (r:=a%b), тогда
НОД(a,b)=НОД(b,r). Действительно, r=a%b, r=a-(a/b)*b. Если
какое-то число делит нацело и a и b, то из приведенного равенства следует,
что оно делит нацело и число r.
#include <stdio.h>;
void main()
{ unsigned long a, b, nod;
 printf("a b="); scanf("%li%li",&a,&b);
 while (a!=0&&b!=0)
 if (a>b) a=a%b; else b=b%a;
 nod=a+b;
 printf("NOD=%li",nod);
}
5.2. Оператор цикла с постусловием do .. while
Для программной реализации циклических процессов с неизвестным числом
повторений существует еще один оператор – оператор цикла с постусловием,
который имеет вид:
 do
 <оператор>
 while (<логическое выражение>);
Этот оператор аналогичен оператору цикла с предусловием, но отличается от
него тем, что проверка условия производится после очередного выполнения
тела цикла. Это обеспечивает его выполнение хотя бы один раз.
Примеры
1) k=0;
 do
 {n=n/10; k=k+1;}
 while (n>0);
2) i=0; s=0;
 do
 i++; s=s+pow(i,2);
 while (i<100);
3) i=0; a=1; s=a;
 do
 {
 i=i+1;
 a=-a*x/i; s=s+a;
 }
 while (fabs(a)>0.0001);
Пример программы
Вычислить квадратный корень вещественного числа x с заданной точностью
ε=0.0001 по итерационной схеме:
( / )
2
1
n  n1  n1
y y x y ,
где yn-1 – предыдущее приближение к корню, yn – последующее
приближение.
Осуждение. Начальное приближение y0 выбирается произвольно. Процесс
вычислений прекращается, когда два последовательных приближения станут
отличаться друг от друга по абсолютной величине менее, чем на величину
заданной точности.
#include <stdio.h>;
#include <math.h>;
void main()
{ const eps=0.0001;
 float x,y0,y1;
 printf("Введите x>0: "); scanf("%f",&x);
 y1=1;
 do
 {
 y0=y1;
 y1=0.5*(y0+x/y0);
 }
 while (fabs(y1-y0)>eps);
 printf("sqrt(%.2f)=%f",x,y1);
}
5.3. Оператор цикла с параметром for
Оператор цикла с параметром имеет следующий формат:
for(<инициализация>;<выражение>;<модификации>)<оператор>
Инициализация используется для объявления и присвоения начальных
значений величинам, используемым в цикле. В этой части можно записать
несколько операторов, разделенных запятой.
Инициализация выполняется один раз в начале исполнения цикла.
Выражение определяет условие выполнения цикла. Если его результат,
равен true, цикл выполняется. Цикл с параметром реализован как цикл с
предусловием.
Модификации выполняются после каждой итерации цикла и служат обычно
для изменения параметра цикла.
Любая из частей оператора for может быть опущена, но точки с запятой
надо оставить на своих местах.
Примеры
1) for (k=1;k<n;k++) if (n%k==0) printf(”%i”,k);
2) for (int i=1,s=0;i<=100;i++) s+=i*i;
3) s=0; f=1;
 for (i=1;i<=n;i++)
 { f=f*i; s=s+f; }
3) for (i=n;i>=1;i--) printf(”%i ”,i*i);
4) Ok=1;
 for (n=2;n<=sqrt(a);i++)
 if (a%n!=0) { Ok=0; break; }
Примеры решения задач
1) Каждое число Фибоначчи вычисляется как f1=0, f2=1, а начиная с
третьего, по формуле fn=fn-1+fn-2. Составить программу, которая
вычисляет последовательность n (n≥3) чисел Фибоначчи.
Обсуждение. Формула, по которой вычисляются числа Фибоначчи относится
к рекуррентным формулам и для реализации данной формулы
достаточно иметь три переменные: f=fn, f1=fn-1 и f2=fn-2. Подготовка к
вычислению следующего элемента последовательности осуществляется
присвоением f1=f2 и f2=f.
#include <stdio.h>;
void main()
{
 int n, i;
 unsigned long f,f1,f2;
 printf("n="); scanf("%i",&n);
 f1=0; f2=1; printf("%li %li ",f1,f2);
 for (i=3;i<=n;i++)
 {
 f=f1+f2; printf("%li ",f);
 f1=f2; f2=f;
 }
 printf("\n");
}
2) Определить, является ли заданное число n простым.
Обсуждение. Простое число – натуральное число, большее единицы, но
не имеющее других делителей, кроме самого себя и единицы. Из
определения следует, что, если заданное число делится хотя бы один раз на
одно из чисел 2,3,…,n-1, то оно составное. В действительности,
достаточно проверить делимость заданного числа на 2,3,…,n/2, или даже на
2,3,…, n (почему?).
#include <stdio.h>;
#include <math.h>;
void main()
{
 int n, i, Ok;
 printf("Введите n>1: "); scanf("%i",&n);
 Ok=1;
 for (i=2;i<=int(sqrt(n));i++)
 if (n%i==0) { Ok=0; break; }
 if (Ok) printf("Простое\n");
else printf("Составное\n");
}
4.4. Оператор перехода
Оператор перехода вызывает передачу управления оператору,
которому предшествует метка:
goto <имя>;
. . .
<имя>: <оператор>
Помеченный <оператор> должен находиться в той же функции, что и
оператор goto, и метка должна быть уникальна.
Метка – это просто идентификатор.
Метка от оператора должна отделяться символом ”:”.
Пример использования оператора
#include <stdio.h>;
#include <math.h>;
void main()
{ float a;
M: printf("Введите a>0: "); scanf("%f",&a);
if (a<=0) goto M;
printf("%.3f",sqrt(a));
}
5.4. Операторы передачи управления
Оператор перехода вызывает передачу управления оператору,
которому предшествует метка:
goto <имя>;
. . .
<имя>: <оператор>
Помеченный <оператор> должен находиться в той же функции, что и
оператор goto, и метка должна быть уникальна.
Метка – это просто идентификатор.
Метка от оператора должна отделяться символом ”:”.
Пример использования оператора
#include <stdio.h>;
#include <math.h>;
void main()
{ float a;
M: printf("Введите a>0: "); scanf("%f",&a);
if (a<=0) goto M;
printf("%.3f",sqrt(a));
}
5.5. Вложенные циклы
Для решения задачи достаточно часто требуется использовать
несколько циклических конструкций, которые расположены внутри друг
друга. Такие конструкции называют вложенными циклами.
Пример решения задачи
1) Натуральное число называют совершенным, если оно равно сумме всех
своих делителей, не считая его самого. Например, 6=1+2+3,
28=1+2+4+7+14. Написать программу нахождения первых совершенных
чисел меньших 10000.
Обсуждение. Единица по определению не является совершенным числом. На
совершенность проверяем все числа n от 2 до 10000. Каждое число n делим
на числа от 1 до n-1 и все делители суммируем (s=s+i). Как только сумма
s делителей равна текущему числу n, выводим n на экран.
#include <stdio.h>;
void main()
{
 long n, i, s;
 for (n=2;n<=10000;n++)
 { s=0;
 for(i=1;i<n;i++) if (n%i==0) s=s+i;
 if (s==n) printf("%i\n",n);
 }
}
5.6. Вычисление сумм
Одним из важных задач практики является вычисление сумм, которые
без компьютера решить было бы весьма трудно.
Вычисление конечных сумм. Общий вид суммы можно записать в виде
     

n
i
n i
S a a a a
1
1 2
... .
Любая сумма вычисляется по рекуррентной формуле, которая получается
следующим образом. Обозначим сумму первых i членов суммы
i
a a a
i
S   ...
1 2
, тогда сумма первых i-1 членов ряда равна
1 1 2 1
...
 
   
i
a a a
i
S . Отсюда легко получим рекуррентную формулу
вычисления суммы
0.
0
, 1,2,..., ,
1
 

  i n S
i i i
S S a .
Общий алгоритм вычисления суммы: требуется задать начальное значение
суммы ряда (в данной постановке задачи S0=0), а затем многократно
вычислять очередной член ряда и добавлять его к ранее найденной сумме
(Si=Si-1+ai).
Примеры
1) Составить программу вычисления суммы
99 100
1
...
3 4
1
1 2
1

 



S  .
Обсуждение. Общий член суммы имеет вид
i i
i
a
(2 1)2
1

 , i=1,2,…,50.
#include <stdio.h>;
void main()
{
 int i; float a, s;
 s=0;
for (i=1;i<=50;i++)
 { a=1.0/((2*i-1)*2*i);s=s+a;}
printf("s=%.4f\n",s);
}
2) Составить программу вычисления для заданного x суммы первых n членов
ряда ...
( 1)!
...
1! 2!
1
2 4 2( 1)


    

n
x x x
S
n
Обсуждение. Общий член ряда имеет вид
( 1)!
2( 1)



i
i
x
i
a , i=1,2,…,n.
Прямое вычисление члена ряда по приведенной общей формуле, когда x
возводится в степень, вычисляется факториал, а затем числитель делится на
знаменатель, имеет два недостатка, которые делают этот способ
непригодным. При возведении в степень и вычислении факториала можно
получить очень большие числа, при делении которых друг на друга
произойдет потеря точности. Второй недостаток связан с количеством
операций. Для уменьшения количества операций следует воспользоваться
рекуррентной формулой получения последующего члена ряда через
предыдущий член. Для получения рекуррентной формулы вычислим
отношение следующего члена ряда к предыдущему:
1 ( 1)!
( 2)! 2
2 3
2 1
1








i
x
x i
x i
a
a
i
i
i
i
,
откуда ai=ai-1x
2/(i-1), i=2,3,…,n, a1=1.
#include <stdio.h>;
void main()
{
 int i,n; float x, a, s;
 printf("x n="); scanf("%f%d",&x,&n);
a=1; s=a;
 for (i=2;i<=n;i++) { a=a*x*x/(i-1); s=s+a;}
 printf("s=%.4f\n",s);
}
Вычисление бесконечных сумм. Общий вид бесконечных сумм имеет вид
      

1
1 2
... ...
i
n i
S a a a a .
Бесконечные суммы вычисляются с некоторой точностью ε. Для достижения
заданной точности требуется суммировать члены ряда, абсолютная величина
которых больше ε. Для сходящегося ряда модуль члена ряда ai при
увеличении i стремится к нулю.
Примеры
1) Дан угол α (|α |≤ 3600
) в градусах. Вычислить sin(α) с заданной точностью
ε =0.000001, если
 

 



0
2 1
180
,
(2 1)! sin( ) ( 1)
i
i
i
x
i
x
x

.
При определении суммы ряда следует использовать рекуррентную
формулу для получения текущего члена ряда. Для этого введем обозначение
ai=(-1)i
x
2i+1/(2i+1)! и вычислим отношение текущего члена к
предыдущему
2 (2 1)
2
( 1) (2 1)!
( 1) (2 1)!
1 2 1
2 1
1

 
 
 

 


i i
x
x i
x i
a
a
i i
i i
i
i
.
Отсюда ai=-ai-1x
2/(2i(2i+1)).
Для определения ai, i=1,2,... достаточно знать a0=x.
#include <stdio.h>;
#include <math.h>;
void main()
{
 const eps=0.000001;
 int i; float x, a, s;
 printf("В градусах угол x="); scanf("%f",&x);
 x=x*M_PI/180; //градусы переводим в радианы
 i=0; a=x; s=a;
 do
 {
 i++;
 a=-a*x*x/(2*i*(2*i+1));
 s=s+a;
 }
 while (fabs(a)>eps);
 printf("sin(x)=%.6f",s);
}
2) Составить программу вычисления значения π с использованием
соотношения
... 2 1
( 1)
... 7
1
5
1
3
1
1
4
1



     

n
n

Обсуждение. Изменение знака моделируется соотношением z:=-z;
#include <stdio.h>;
#include <math.h>;
void main()
{
 const eps=0.000001;
 long i; double z, a, s;
s=1; z=1; i=1;
 do
 { i++; z=-z; a=z/(2*i-1); s=s+a;}
while (fabs(a)>1E-6);
 s=4*s;
printf("pi=%lf",s);
}