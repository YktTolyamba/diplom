<style>h3 {margin-bottom: -15px; }</style><center><h3>10. Функции</h3></center>
С увеличением объема программы становится невозможным удерживать в
памяти все детали. Функции нужны для упрощения структуры программы,
т.е. задача может быть разделена на более простые и обозримые подзадачи.
Записав функцию один раз достаточно знать как ее вызвать.
Модули - это группировка функций и связанных с ними данных в отдельные
файлы.
Функция – это группа операторов, выполняющая законченное действие. К
функции можно обратиться по имени, передать ей значения и получить из
нее результат.
Любая функция должна быть объявлена и определена.
Объявлений может быть несколько, а определение только одно.
Формат функции:
[класс] или <имя> ([список параметров]) [throw(исключения)]
{<тело функции>}
Рассматриваем составные части определения.
[ ] – обязательный параметр
- с помощью модификатора класс можно явно задать область видимости
функции существуют 2 класса:
1) extern – глобальная видимость во всех модулях программы.
2) static – видимость только в пределах модуля, в котором определена
функция.
- тип возвращаемого функцией значения может быть любым, кроме массива
и функции (но может быть указателем на массив или функцию). Если
функция не должна возвращать значение, указывается тип void.
- список параметров определяет величины, которые требуется передать в
функцию при ее вызове. Элементы разделяются запятыми. Для которого
параметра указывается его тип и имя (в объявлении имя можно опускать).
2
- список исключений дает информацию для использования функции и
гарантию, чтобы при возникновении непредвиденного исключения эта
ситуация будет обнаружена.
В определении, в объявлении и при вызове одной и той же функции типы и
порядок следования параметров должны совпадать.
Пример 1: Обмен через возвращение
#include <iostream.h> // библиотека ввода/ вывода С++
int sum (int a, int b); // объявление функции
void main()
{ int a,b,c;
cout <<”a _ b _ c=”; cin>>a>>b>>c;
cout<<”a+b=”<<summ(a,b)<<endl; //вызов функции
cout<<”b+c”<<summ(b,c)<<’\n’; // вызов функции
}
int summ(int a, int b) // определение функции
{ return (a+b); // возвращаемое значение
}
Заголовочный файл <iostream.h> содержит описание набора классов для
управления вводом/выводом.
В нем определены стандартные объекты – потоки cin для ввода с клавиатуры
и cout для вывода на экран.
Также операции помещения в поток << и чтения из потока >>, endl – конец
строки и enter.
Упражнение 1:
Даны x, y. Вычислить
x
y x y x y e
x x y x y tg x y
f x y
    
     

[ sin ( ) cos ( )]
[ sin ( ) cos ( )] ( )
( , )
3 2
3 2 2
#include <iostream.h>
#include <math.h>
float f1(float x, float y)
{return (x+pow(sin(x+y),3)+pow(x-y,2));}
3
void main()
{ float x,y,f;
cout<<”x _ y=”; cin>>x>>y;
f=(pow(f1(x,y),2)+tan(x+y))/(f1(y,x)+exp(x));
cout<<”f=”<<f<<endl;
}
Упражнение 2: Написать функцию нахождения max(a,b) и использовать ее
для вычисления y=max(a,b)+max(c,d).
#include <iostream.h>
#include <math.h>
int max(int a, int b);
void main()
{ int a,b,c,d,y;
cout <<”a _ b _ c _ d”); cin>>a>>b>>c>>d;
y=max(a,b)+max(c,d);
cout<<”y=”<<y<<endl;
}
int max(int a, int b)
{ int temp;
if (a<b) temp=b;
else temp=a;
return temp;
}
Упражнение 3: Даны вещественные a, b. Найти
.
min(1,2 max( , ))
max( ,min( , ))
a b
a a b b
z



#include <iostream.h>
float max(float a, float b)
4
{if (a>b) return (a); else return(b)}
float min (float a, float b)
{if (a>b) return(b); else return(a)}
void main()
float a,b,z);
cout <<”a _ b=”; cin >>a>>b;
z=max(a,min(a+b,b))/min(1,2+max(a,b));
cout<<”z=”<<z<<endl;
Существуют два способа передачи параметров в функцию:
- по значению
- по адресу.
При передаче по значению в стек заносятся копии значений аргументов, и
операторы функции работают с этими копиями. Доступа к исходным
значениях параметров из функции нет => нет возможности их изменить.
При передаче по адресу в стек заносятся копии адресов аргументов, а
функция осуществляет доступ к ячейкам памяти по этим адресам и может
изменить исходные значения аргументов.
Пример 2: Возврат значений через параметр
Даны a и b – числа. Обменять значения этих переменных.
#include <iostream.h>
void swap (float &a, float &b)
{ float temp;
temp=a; a=b; b=temp;}
void main()
{float a,b;
cout <<”a _ b=”; cin>>a>>b;
swap(a,b);
cout<<a<<”и”<<b<<’\n’;
}
5
Пример 3: (обобщающий пример1 и пример2)
Возвращение значений через return и через параметры
#include <iostream.h>
int f(int i, int &a)
{ int b,s;
b=i*i+1; a=b-i; s=a+b; b=pow(b,2);
return b;
}
void main()
{ int x,y;
cout<<”x=”; cin>>x;
if (f(x,y)>10)
{y=y+4;x=9;}
cout<<”x=”<<x<<’_’<<”y=”<<y;
}
x=2 на экране что будет?
“x=”2
b=4+1; a=5-2=3; s=5+3=8; b=25
y=3+4=7; x=9
при x=1
b=2; a=1;s=3;b=4 => x=1; y=1 (т.к. &, то меняется)
Задача массивов в качестве параметров
Пример 4: Работа с одномерным массивом.
При работе с массивами обмен всегда производится по адресу, т.е. в
функцию передается указатель на его первый элемент, при этом информацию
о количестве элементов следует передавать через отдельный параметр.
#include <iostream.h>
void vvod (int a[], const in n)
6
// варианты: void vvod (const int *a, const int n)
// или void vvod (int a[n], int n) – n должен быть константой
// т.е. возвращает через адрес одномерного массива
{ int i;
for (i=1; i<=n; i++) cin>>a[i];
}
int summa (int a[], const int n)
int s=0;
{for (int i=1; i<=n, i++) s+=a[i];
return s
}
void main ()
{ int s, i, a[100], b[20], n1=10, n2=5;
vvod (a,n1);
s=summa(a,n1);
cout<<”s=”<<s<<’\n’;
}
Пример 5: Работа с двумерными массивами.
При передаче многомерных массивов все размерности должны передаваться
в качестве параметров. Внутри функции массив интерпретируется как
одномерный, а его индекс пересчитывается в программе.
#include <iostream.h>
void vvod (int a[][20], int n1, int n2)
// a[][20] обязательно нужно поставить, n1 кол-во строк, n2 кол-во столбцов
// void (int **a, int a1, int n2)
{ int i,j;
for (i=1; i<=n1; i++)
for (j=1; j<=n2; j++) cin>>a[i][j];
}
int max (int a[][20], int n1, int n2)
7
{ int i,j, max;
max=a[1][1];
for (i=1; i<=n1; i++)
for (j=1; j<=n2; j++)
if (a[i][j]>max) max=a[i][j];
return max;
}
void main()
{ int x[5][20], y[10][20];
vvod (x,5,10); cout <<max(x,5,10)<<endl;
vvod (y,10,20); cout<<max(y,10,20);
}
Значит, в памяти элементы матрицы располагаются следующим образом:
первая строка вторая строка третья строка
{заняты по 20 элементов; главное, чтобы количество совпадало}
Упражнение 4: Даны два одномерных массива a и b:
a1, a2, …, an и b1, b2, …, bm
Заменить отрицательные элементы на 100 и вывести результат на экран.
Значит 3 обращения:
1. Функция ввода {vvod}
2. Функция обработки {obr}
3. Функция вывода {vyvod}
#include <iostream.h>
void vvod (int a[], const int n)
{ int i;
for (i=1; i<=n; i++)
cin>>a[i];
8
}
void obr (int a[], const int n)
{ int i;
for (i=1; i<=n; i++)
if (a[i]<0) a[i]=100;
}
void vyvod (int a[]; const int n)
{ int i
for (i=1; i<=n; i++)
cout <<a[i]<<endl;
}
void main ()
{ int a[100], b[100]; n=10;m=20;
vvod(a,n); vvod(b,m); obr(a,n); obr(b,m); vyvod(a,n); vyvod(b,m);
}
Различные варианты описания формальных параметров (для массивов)
int summa (int a[], const int n); // описание заголовка можно написать
следующим образом:
int summa (const int *a, const int n);
int summa (int a[n], int n); // в a[n] n – только константа
Параметры со значениями по умолчанию.
Чтобы упростить вызов функции в ее заголовке можно указать значения
параметров по умолчанию. Эти параметры должны быть последними в
списке и может опускаться при вызове функции.
Если при вызове параметр опущен, то должны быть опущены все параметры
стоящие за ним.
Пример: (заголовок функций)
int f(int a; int b=0);
void f1(int, int=100, char* _ =0);
// ни один параметр не имеет имени.
9
их можно вызывать следующим образом:
y=f(100); здесь b=0
y1=f(a,1); здесь b=1
fa(a), f1(a,10); f1(a,10,”dima”);
Упражнение 5: Даны два одномерных массива: a1, a2, …, an и b1, b2, …, bm-
целого типа.
Написать программу нахождения S=min{ai}+min{bi}
Определение минимума оформить в виде функции.
#include <iostream.h>
void vvod (int a[], const int n)
{ int i;
for (i=1; i<=n; i++)
cin>>a[i];
}
int min (int a[], const int n) // конст не обязательно
{ int i, mini; mini=a[1];
for (i=2; i<=n; i++)
if (mini>a[i]) mini=a[i];
return (mini);
}
void main()
{ int a[100], b[90], n, m, s; //{n>=99, m>=89}
cin>>n>>m;
vvod(a,n); vvod(b,m);
s=min(a,n)+min(b,m);
cout<<”s=”<<s<<andl;
}
10
Упражнение 6: Дан одномерный массив a1, a2, …, an вещ. типа. Сортировать
по возрастанию заданный массив.
#include <iostream.h>
void vvod (float a[], const int n)
{ int i;
for (i=1; i<=n; i++)
cin>>a[i];
}
void sort (float a[], int n) // метод пузырька
{ int i,k; float t;
for (k=1; k<=n-k; k++)
for(i=1; i<n-k; i++)
if (a[i]>a[i+1])
{ t=a[i]; a[i]=a[i+1]; a[i+1]=t;}
}
void vyvod (float a[], const int n)
{ int i;
for (i=1; i<=n; i++)
cout <<a[i]<<”_”;
}
void main()
{ int i; float a[100];
cin>>n;
vvod (a,n); sort(a,n); vyvod(a,n);
}
Упражнение7: Дан двумерный массив {aij}. Транспортировать и вывести на
экран. Дополнительный массив не использовать.
#include <iostream.h>
void vvod (int a[][20], int n)
11
{ int i,j;
for (i=1; i<=n; i++)
for (j=1; j<=n; j++)
cin>>a[i][j];
}
void vyvod (int a[20][20], int n)
{ int i,j;
for (i=1; i<=n; i++)
{ for (j=1; j<=n; j++)
cout <<a[i][j]<<”_”;
if (j=n) cout<<”\n”;}
}
void drank (int a[20][20], int n)
{ int i,j,k;
for (i=1; i<=n; i++)
{ for (j=i+1; j<=n; j++)
{k=a[i][j]; a[i][j]=a[j][i]; a[j][i]=k;}}
}
void main ()
{ int n, a[100][100]; cin >>n;
vvod(a,n); drank(a,n); vyvod(a,n);
}