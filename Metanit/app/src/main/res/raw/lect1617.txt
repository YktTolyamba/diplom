<style>h3 {margin-bottom: -15px; }</style><center><h3>8. Строки</h3></center>
Последовательность символов, заключенная в кавычки “ ” называется
строковой константой.
Пример: “ПМ-09”
Переменная, которая принимает значения строковых констант
называется строковой переменной.
Примеры описания строковых переменных:
char s[50], c[10][10], a[]=”ПМ-09”, *x, *y=”ИМИ”;
 (какая длина? 5)
разнообразие описания строковых переменных, описывается как массив.
*x – указатель на строковую переменную, т.е. это адрес (где хранится
некоторая строковая переменная).
* - операция ссылки по указателю.
& - чтобы получить адрес участка памяти.
char *x
*x обозначает объект типа char, на который указывает x.
Ввод, вывод значения строковых переменных
Ввод: printf (“S=”); scanf(”%S”, S); адрес не ставим, т.к. имя само
является адресом.
Пусть в памяти 50 байтов
на строке: S = ПМ-09 Enter
В памяти будет размещена как массив символов:
0 1 2 3 4 49
П М - 0 7 \0 \0 …
 знак конца строки
\ - обратная конца строки
\0 – нуль
‘\0’ – нулевой символ, числовой код которого равен нулю.
Конец строки можно определить через знак конца, подразумевается, что
символ ‘\0’ не может встречаться в нормальном тексте.
Вопрос:
Если введем на экране:
S = ИМИ ПМ-09
После этого значение S=’ИМИ’. Функция scanf читает до первого пробела
(до первой ошибки)
Чтобы прочитать полностью, то gets(s) – читает до конца строки.
Функция gets(s) – определена только для строковых переменных.
 gets(s) из stdio.h // char *gets (char *S); Считывает строку S из
стандартного входного потока.
Gjckt gets(s) S = ‘BVB GV-09’
printf(“S=”); gets(s) Здесь никаких форматов не даем, т.к. S само указывает
формат.
Вывод строки: printf(“s=%s”,s);
2
Пусть c[10][10] //вывод как матрица без пробелов, без ничего.
for (i=0; i<=9; i++)
{ for (j=0; j<=9; j++)
 printf(“%c”,c[i][j]);
 (символ)
printf(“\n”);
}
Пример1: Дана строка S. Найти количество пробелов в этой строке.
#include…
void main()
{ char S[80]; int i, k, l;
 printf(“s=”); gets(s);
 l=strlen(s);
 //strlen(s) – определяет количество символ из библиотек: string.h
k=0;
 for (i=0; i<l; i++)
 if (s[i]==’ ’) k++;
 printf (“k=%i”, k);
}
Упражнение 1: Дана строка S без пробелов. Заменить все буквы о на а.
(используя функцию scanf)
#include
void main()
{ char S[80]; int i,l;
 printf(“s=”); scanf(“%s”,s);
 l=strlen(s);
 for (i=0; i<l; i++)
 if (s[i]==’o’) s[i]=’a’;
 printf(“s=%s”,s);
}
Пример 2: Дан текст. Подсчитать количество слов в данном тексте. Текст дан
в одну строку и точка, запятая ставится сразу после слова.
_ ИМИ _ _ ЯГУ _ _ _ ПМ-09 (3 слова)
Первым пробел тоже может быть. Значит если первый не пробел, то
прибавляем 1 и т.д.
Значит, проверяем, если i – пробел и i+1 – не пробел, то будет столько же
слов.
#include
void main()
…
printf(“s=”); gets(s);
l=strlen(s); k=0;
for (i=0; i<l-1; i++) {либо i<l-k}
3
if (s[i]==’_’ && s[i+1]!=’_’) k++;
if (s[0]!=’_’) k++; // проверяем первый является пробелом или нет.
printf(“k=%i”,k);
Упражнение 2: Дан текст. Подсчитать количество вхождений строки “он” в
заданный текст.
printf(“s=”); gets(s);
l=strlen(s); k=0;
for (i=0; i<l-1; i++)
if (s[i]==’о’ && s[i+1]==’Н’) k++;
printf(“k=%i”,k);
Функции для работы со строками
Файлы strinh.h
Функция Правила записи Краткое описание
действия
1. strcat
Конкатенация
строк
char *strcat(char *s1, char
*s2)
Складывает строки
S=strcat(S1,S2);
В паскале есть S=S1+S2 (C++ 5.5 – можно, а в 3.1 нельзя)
Пример:
S1=”ИМИ _ ”;
S2=”ПМ-09”;
S=”ИМИ _ ПМ-09”;
2. strchr char *strchar(char *s, int ch); Ищет в строке s первое
вхождение символа ch
3. strcpy (copy) char strcpy(char *s1, char
*s2);
Копирует одну строку в
другую.
4. strlen unsigned strlen(char *s) Длина строки s.
5. strstr char *strstr (char *s1, char
*s2)
Ищет подстроку в строке.
Пример:
k=strstr(s1;s2); s1=”ПМ-09”
 s2=”ИМИ _ ПМ-09”
k=4 (находит первое появление слова)
Остальные функции рассмотреть самим.
6. strcmp int strcmp (char *s1, char *s2); сравнивает строки s1 и s2
<0, если s1<s2
=0, если s1=s2
>0, если s1>s2.
7. strcspn int strcspn (char *s1, char *s2); определяет длину
первого сегмента строки
s1, содержащего
символы, не входящие во
4
множество символов
строки s2.
8. strdup char *strdup (char *s); выделяет память и
переносит в нее копию
строки s.
9. strlwn char *strlwn (char *s); преобразует буквы
верхнего регистра в
строке в
соответствующие буквы
нижнего регистра.
10. strncmp int strncmp (char *s1, char *s2, int k); сравнивает части строк s1
и s2, причем
рассматривается k
символов.
<0, если s1<s2
=0, если s1=s2
>0, если s1>s2.
11.strnicmp int strnicmp(char *s1, char *s2, int k
);
сравнивает не более k
символов строки s1 и
строки s2, не делая
различия регистров.
12. strnset char *strnset (char *s1, int c, int k); заменяет первые k
символов строки s1
символом c
13. strpbrk char *strpbrk(char *s1, char *s2); ищет в строке s1 первое
появление любого из
множества символов,
входящих в строку s2.
14. strrchr char *strcchr(char *s, int c); ищет в строке s
последнее вхождений
символа с.
15.strset char *strset(char *s, int c); заполняет строку s
заданным символом c.
16. strspn int strspn(char *s1, char *s2); определяет длину
первого сегмента строки
s1, содержащего только
символы, из множества
символов строки s2.
17. strupn char *strupn (char *s); преобразует буквы
нижнего регистра в
строке s в буквы верхнего
регистра.
stdlib.h // рассматриваемые функции для работы со строками
5
1. atof double atof (const char *s); преобразует строку в
вещественное число.
Пример: s=”3.14159” – строка
 k=atof(s); k=3.14159 – как число
 Если встретится символ, то будет ошибка.
2.ultao char *ultao (unsigned long v,
char *s, int k);
преобразует беззнаковое
длинное целое v в строку
s. k - основание
3. atoi int atoi (const char *s); преобразует строку в
целое число.
4. atol long atol (const char *s); преобразует строк в long
5. itoa char *itoa (int v, char *s, int
k);
число переводят в строку.
k – основание
6. ltoa char *ltoa(long v, char *str,
int k);
long в строку.
7. strtod double strtod(char *s, char
**p);
преобразует символьную
строку s в число дробной
точности.
8.fcvt char *fcvt (double value, int
ndig, int *dec, int *sign)
посмотреть в help-e
перевод вещественных
чисел в строку.
9. strtok д.з. д.з.
10. strtol д.з написать фрагменты из
примеров в help-e
Пример: v=3.14159; ndig=8
 s=fcvt(v, ndig, &dec, &sign)
 s=3.1415900 dec=1 sign=0
ndig – ставим после точки s цифр.
dec – точка стоит после первого.
sign=0 – означает знак числа +
Упражнение: Удаление символов
Дан текст. Удалить все запятые.
(нужно использовать дополнительную переменную)
char s[80], r[80];
l=strlen(s); k=0;
for (i=0; i<l; i++)
 if (s[i]!=’,’) r[k++]=s[i];
r[k++]=’\0’;
Пример 1: Дана строка s. Получить строку записанную в обратном порядке.
#include <stdio.h>
#include <stdlib.h>
void main ()
6
{ char s[200], r[200];
 int k, i, l;
printf (“s=”); scanf (“%s”,s); // текст задач без пробелов
l=strlen(s); k=0;
for (i=l-1; i>=0; i--)
r[k++]=s[i];
r[k]=’\0’; // \0-знак конца строки
printf(“s=%s”,r);
}
Пусть s=123
1 2 3 \0 …
0 1 2 3
l=3
r=
1 2 3 \0 …
0 1 2 3
Пример 2: Дан текст (строчный). Определить слова и написать на экране.
Разделителями м.б. только пробелы (их м.б. сколько угодно), в точек и
запятых нет.
т.е. ИМИ _ ПМ-09 _ ЯГУ ИМИ
 ПМ-09
 ЯГУ
#include <stdio.h>
#include <stdlib.h>
void main ()
{ char s[200], r[200];
 int k, i, l;
printf (“s=”); gets(s);
k=0;
for (i=0; s[i]!=’\0’; i++)
{ if (s[i]!=’_’) r[k++]=s[i];
 else if (r[0]!=’\0’)
{ r[k]=’\0’; printf (“%s”,r);
 r[0]=’\0’; k=0;
}
}
if (r[0]!=’\0’)
{r[k]=’\0’; printf(“%s”,r);} // проблема граничного условия
}
Упражнение 1: Дана строка s. Подсчитать количество цифр, входящих в s.
printf(“s=”); gets(s);
7
k=0;
for (i=0; s[i]!=’\0’; i++)
if (s[i]>=’0’ && s[i]<=’9’) k++;
либо: printf (“s=”); gets(s);
k=0; l=strlen(s);
for (i=0; i<l; i++) и т.д.
Упражнение 2: Дан текст. Подсчитать количество слов «мир» входящих в
исходный текст. (подстрока м.б.) миру-мир
l=strlen(s); k=0;
for (i=0; i<=l-3; i++)
if (s[i]==’M’ &&s[i+1]=’и’ &&s[i+2]=’р’)
k++;
Упражнение 3: Дан однострочный текст S. Удалить лишние пробелы, между
словами должен быть 1 пробел.
Пример: _ _ 123 _ _ 124 _ _ 618 _ _ _ 9 _ _
 123 _ 124 _ 618 _ 9
printf(“s=”); gets(s);
l=strlen(s); k=0; i=0; r=l;
for (i=0; i<=l-1; i++)
if (s[i]=’_’) {++k; break;} // добрался до символа, которая не является
пробелом
for (i=l-1; i>=k; i--)
if (s[i]=’_’) {p=I; break;} // нашел номер последнего символа
for (i=k; i<=p-2; i++)
if (s[i]!=’_’ || s[i+1]!=’_’) b[k+1]=s[i];
b[k]=’\0’;
printf(“s=%s”,b);