<style>h3 {margin-bottom: -15px; }</style><center><h3>15. Контейнерные классы</h3></center>
Контейнерные классы — это классы, предназначенные для хранения данных, организованных
определенным образом. Примерами контейнеров могут служить массивы, линейные списки
или стеки. Для каждого типа контейнера определены методы для работы с его элементами; не
зависящие от конкретного типа данных, которые хранятся в контейнере, поэтому один и тот
же. вид контейнера можно использовать для хранения, данных различных типов. Эта
возможность реализована с помощью шаблонов классов, поэтому часть библиотеки С++, в
которую входят контейнерные классы, а также алгоритмы и итераторы, о которых будет
рассказано в следующих разделах, называют стандартной библиотекой шаблонов (STL —
Standard Template library).
Контейнеры можно разделить на два тала: последовательные и ассоциативные.
Последовательные контейнеры обеспечивают хранение конечного количества од-
нотипных величин в виде непрерывной последовательности. К ним относятся
векторы (vector), двусторонние очереди (deque) к списки (list), а также так на-
зываемые адаптеры, то есть варианты, контейнеров — стеки(stack), очереди
(queue) и очереди с приоритетами (priority_queue).
Ассоциативные контейнеры обеспечивают быстрый доступ к данным по ключу. Эти контейнеры
построены на основе сбалансированных деревьев. Существует пять типов ассоциативных
контейнеров: словари (map), словари с дубликатами(multimap), множества (set), множества с
дубликатами(multiset) и битовые множества (bitset).
Практически в любом контейнерном классе определены поля перечисленных
ниже ТИПОВ:
Поле Пояснение
value_type Тип элемента контейнера
size_type Тип индексов, счетчиков элементов и т.д.
iterator Итератор
const_iterator Константный итератор
reverse_iterator Обратный итератор
const_reverse_iterator Константный обратный итератор
reference Ссылка на элемент
const_reference Константная ссылка на элемент
key_type Тип ключа (для ассоциативных
контейнеров)
key_corapare Тип критерия сравнения (для
ассоциативных контейнеров)
Итератор является аналогом указателя на элемент. Он используется для просмотра контейнера в
прямом или обратном направлении. Все, что требуется от итератора — уметь ссылаться на элемент
контейнера и реализовывать операцию - перехода к его следующему элементу. Константные
итераторы используются тoгда, когда значения, соответствующих элементов контейнера не
изменяются (более подробно об итераторах рассказывается, в разделе «Итераторы», с. 328).
При помощи итераторов просматривать контейнеры не заботясь о фактических типах данных,
используемых для доступа к элементам. Для этого в каждом контейнере определено несколько
методов, перечисленных ниже.
М е т о д П о я с н е н и е
i t e r a t o r b e g i n ( ),
c o n s t_ i t e r a t o r b e g i n ( ) c o n s t
Указывают на первый элемент
iterator e n d ( ) ,
c o n s t _ i t e p a t o r end() const
Указывают на элемент, следующей
за последним:
2
reverse iterator rbegin(),
const_reverse_ i t e r a t o r rbegin() const
Указывают на первый элемент в
обратной последовательности
reverse_iterator rend(),
const_reverse_ i t e r a t o r rend() const
Указывают на элемент, следующий
за последним, в
обратнойпоследовательности
Во всех контейнерах определены методы, позволяющие получить сведения о размере контейнеров:
М е т о д П о я с н е н и е
size() Число элементов
maxsize() Максимальный размер контейнера (порядка
миллиарда элементов)
empty() Булевская функция, показывающая, пуст ли
контейнер
Другие поля и методы контейнеров мы рассмотрим по мере-необходимости.
STL определяется в 13 заголовочных файлах:
algorithm deque functional iterator list map
memory numeric queue set stack utility vector
Последовательные контейнеры
Векторы (vector), двусторонние очереди (deque) и списки (1ist) поддерживают
разные наборы операций, среди которых есть совпадающие операции. Они, могут
быть реализованы с разной эффективностью:
Операция Метод vector deque list
Вставка в начало push_front - + +
Удаление из начала pop_front - + +
Вставка в конец push_back + + +
Удаление из конца pop_back + + +
Вставка в произвольное место insert (+) (+) +
Удаление из произвольного места erase (+) (+) +
Произвольный доступ к элементу [].at + + -
Знак + означает, что соответствующая операция реализуется за постоянное вре-
мя, не зависящее от количества n элементов в контейнере. Знак (+) означает, что
соответствующая операция реализуется за время, пропорциональное n. Для ма-
лых n время операций, обозначенных +, может превышать время операций,
обозначенных (+). но для большого количества элементов последние могут оказаться
очень дорогими.
Как видно из таблицы, такими операциями являются вставка и удаление
произвольных элементов очереди и вектора, поскольку при этом в ее последующие
элементы, требуется переписывать на новые места.
Итак, вектор — это структура, эффективно реализующая произвольный доступ
к элементам, добавление, в конец и удаление из конца.
Двусторонняя очередь эффективно реализует произвольный доступ к элементам,
добавление в оба конца и удаление из обоих, концов.
Список эффективно реализует вставку и удаление элементов в произвольное место,
но не имеет произвольного доступа к своим элементам.
Пример работы с вектором. В файле находится произвольное количество целых
чисел. Программа считывает их в вектор и выводит на экран в том же порядке.
Пример 1.
3
#include <fstream>
#include <vector>
#include <iostream>
#include <conio.h>
using namespace std;
void main(){
 ifstream in("input.txt");
 vector<int> v;
 int x, i;
 while (in>>x, !in.eof()) v.push_back(x);
 for (i= 0; i<v.size();i++) cout<<v[i]<<" ";
getch();
}
Пример 2.
#include <fstream>
#include <vector>
#include <iostream>
#include <conio.h>
using namespace std;
void main(){
 ifstream in("input.txt");
 vector<int> v;
 int x;
 while (in>>x, !in.eof()) v.push_back(x);
 for (vector <int>::iterator i= v.begin(); i!=v.end();i++)
cout<<*i<<" ";
 getch();
}
Пример 3.
#include <fstream>
#include <vector>
#include <iostream>
#include <conio.h>
using namespace std;
void main(){
 ifstream in("input.txt");
 vector<int> v;
 int x;
 while (in>>x, !in.eof())
 v.push_back(x);
 for (vector <int>::iterator i= v.begin(); i!=v.end();i++)
cout<<*i<<" ";
 getch();
}
Поскольку файл содержит целые числа, используется соответствующая специа-
лизация шаблона vector – vector<int>. Для создания вектора v используется кон-
структор по умолчанию. Организуется цикл до конца файла, в котором из него
4
считывается очередное целое число. С помощью метода push_back оно заносится
в вектор, размер которого увеличивается автоматически.
Примеры конструкторов:
// Создаетдя вектор из 10 равных единице элементов:
vector <int> v2 (10,1);
//Создается вектор, равный вектору vl:
vector <int> v4 (v1);
// Создается вектор из двух элементов, равных первым двум элементам vl:
vector <int> v3 (vl.begln(), vl begin()+ 2);
// Создается вектор из 10 объектов класса monstr (см. с. 183)
// (работает конструктор по умолчаний):
vector <monstr> ml (10);
// Создается вектор из 5 объектов класса monstr с заданным именем
//(работает конструктор с параметров char*):
vector <monstr> m2 (5, monstr("Вася"));
В шаблоне vector определены операция присваивания и функция копирования:
vector<T>& operator=(const vector<T>& х);
void assign(size_type n, const Т& value);
template «class InputIter>
void assign(InputIter first, InputIter last);
Здесь через T обозначен тип элементов вектора. Вектора можно присваивать друг
другу точно так же, как стандартные типы данных или строки. После присваива-
ния размер вектора становится равным новому значению, все старые элементы
удаляются.
Функция assign в первой форме аналогична по действию конструктору 2, но при-
меняется к существующему объекту. Функция assign во второй форме пред-
назначена для присваивания элементам вызывающего вектора значений из диа-
пазона, определяемого итераторами first и last, аналогично конструктору 3,
например:
vector <int> vl,v2;
// Первым 10 элементам вектора vl присваивается значение 1:
vl.assign(10,1);
// Первым 3 элементам вектора vl присваиваются значения v1[5], vl[6], vl[7]:
v2.assign(vl.begin()+5,vl.begln()+8);
Итераторы класса vector перечислены в табл. 12.
Доступ к элементам вектора осуществляется с помощью следующих операций и методов:
reference operator[](size_type n>;
const.reference operator[](size_type n ) const;