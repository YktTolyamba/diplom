<style>h3 {margin-bottom: -15px; }</style><center><h3>6. Одномерные массивы</h3></center>
Общий формат описания:
<тип> <имя>[[кол-во элементов]];
[] – необязательный параметр.
Массив – это упорядоченный набор однотипных значений – компонент
массива. Тип компонент называется базовым типом массива.
В квадратных скобках задается количество элементов массива (размерного).
Элементы массива нумеруются с нуля.
При описании массива используются те же модификаторы (класс памяти,
const и инициализатор), что и для простых переменных.
Инициализирующие значения для массивов записываются в фигурных
скобках.
Примеры:
float a[10]; //описание массива из 10 вещественных чисел, 1-й
индекс = 0, последний = 9.
float b[]={1,2,3}; //размерность необязательный параметр;
b[0]=1; b[1]=2; b[2]=3;
int c[5]={3,2,1}; // c[0]=3; c[1]=2; c[2]=1; c[3]=0; c[4]=0;
Ввод одномерного массива:
а) Наглядный ввод
for (i=1; i<=n; i++)
{printf(“a%i=”,i); scanf(“%i”,&a[i]);}
На экране появится:
a1=5
a2=-30
a3=40
б) Ненаглядный ввод
for (i=1; i<=n; i++) scanf(“%f”,&x[i]);
хотим ввести: n=3 // 32, -33, 100
1. 32 -33 100 Enter
2. 32 Enter
-33 Enter
100
Значит разделителями ввода могут быть ‘_’ – пробел или Enter
Упражнение 1: Написать фрагмент программы ввода одномерного массива
a0, a1,…, a10.
for (i=1; i<=10; i++)
{printf(“a%i=”,i);
scanf(“%i”,&a[i]);}
2
Пример: Найти сумму элементов массива.
#include <stdio.h>
void main(){
const int n=10;
int i,s;
int a[n];
for (i=1; i<=n; i++)
{printf(“a%i=”,i);
scanf(“%i”,&a[i]);
}
s=0;
for (i=1; i<=n; i++)
s=s+a[i];
printf(“s%i=”,s);
}
Вывод одномерного массива.
а) Наглядный вывод
a1,…, an.
for (i=1; i<=n; i++)
printf(“a%i=%i\n”,i,a[i]);
Пример: n=3; a1=1; a2=100; a3=4
На экране:
a1=1
a2=100
a3=4
б) Ненаглядный вывод
for (i=1; i<=n; i++)
printf(“%.2f ”,a[i]);
n=3; a1=0,1; a2=-12,236; a3=100
На экране: 0.10 -12.24 100.00
Чтобы опустить курсор вниз, добавляем
printf(“\n”);
Пример: Даны целые числа a1,…, an . Отрицательные элементы массива
заменить на -1, неотрицательные элементы – на 1.
#include <stdio.h>
void main(){
int i,a[10];
for (i=1; i<=10; i++)
{printf(“a%i=”,i); scanf(“%i”,&a[i]);}
for (i=1; i<=10; i++)
3
if a[i]<0 a[i]=-1; else a[i]=1;
for (i=1; i<=10; i++)
printf(“a%i=%i”,i,a[i]);
}
Поиск в одномерном массиве.
1) Линейный поиск (последовательный, полный поиск)
Как искать самого высокого студента в группе? Начиная с самого начала до
конца смотрим (сравниваем) рост.
В сортированном массиве – бинарный поиск.
В несортированном – нет ор. методов.
Линейный поиск осуществляется в несортированных массивах, при этом
количество операций пропорционально числу элементов.
Если n элементов, то количество операций имеет порядок n (O(n)).
Пример 1: Пусть задан одномерный массив a1,…, an. Найти значение
максимального элемента.
Алгоритм:
max=a[1]
for (i=2; i<=n; i++)
if (max<a[i]) max=a[i];
Пример 2: Дан одномерный массив. Найти значение и местоположение
максимального элемента.
В данном случае нужно найти только местоположение.
k=1;
for (i=2; i<=n; i++)
if (a[k]<a[i]) k=i;
printf(“max=a%i=%f”,k,a[k]);
Вопрос: 3,6,9,7,9,9
Что выйдет на экране? Какой из 9 выйдет?
< → первый max
<= → последний max
Как найти 2,3 максимум?
2,3 максимум – за 2 прохода, 1-й раз находим значение максимума, 2-й
проход – находим.
Минимум? Что изменится?
min=a[1];
for (i=2; i<=n; i++)
if (min>a[i]) min=a[i];
4
Пример 3: Задан одномерный массив: a0, a1,…, an-1. Найти первый
отрицательный элемент. Если отрицательных нет, то сообщить об этом.
Ok=0;
for (i=0; i<=n; i++)
if (a[i]<0) {Ok=1; break;}
if(Ok) printf(“%f\n”,a[i]); else printf(“нет отр.\n”);
Что будет? 10,0,-3,4,-6,8,-9,0,1
n=3 10,100,0
Что появится на экране? Ok чему равно?
Упражнение 2: Найти 2-й отрицательный элемент, если не второго, то
сообщить об этом.
Ok=0;
for (i=0; i<=n; i++)
if (a[i]<0)
{for (j=i+1; j<n; j++)
if (a[j]<0) {Ok=1; break;} break}
if(Ok) printf(“%i %f\n”,j,a[j]); else printf(“нет 2 отр.\n”);
k=0;
for (i=0; i<=n; i++)
if (a[i]<0) {k++; if(k= =2) break;}
if(k= =2) printf(“%i %f\n”,i,a[i]); else printf(“нет отр.\n”);
Что поменяется, если требуется найти 3-й отрицательный?
—//— 2-й четный?
((a[i]%2=0)
Опр. 3 отрицательный, 3-е число, которое делится на 7 и т.д.
(поменяется только условие)
2-й отрицательный с конца? Что поменяется?
for (i=n-1; i>=0; i--)
2) Бинарный поиск (Дихотомия, метод деления пополам, метод
половинного деления)
Данный метод используется только для сортированных и с разными
элементами массивов.
Когда элементы разные, то быстро находятся.
x 1 2 10 13 15 50 100 1000 1001
• • • • • • • • •
1 2 3 4 5 6 7 8 9
Будем искать элемент p=100.
5
Как видим, последовательность сортирована по возрастанию (м. по
убыванию).
Обозначим через a первый элемент, b последний элемент.
Средний элемент обозначим mid = (a+b)/2=5
x[mid] сравниваем с p.
x[mid]<p, значит переносим a вправо на mid+1.
т.е. a=6
mid = (a+b)/2 = (6+9)/2 => 7
a[7] сравниваем с p => равно.
Нашли решение через 2 операции, по порядку было бы 7 операций.
Пусть p=2 mid = (a+b)/2 = 5, т.к. p < x[mid] (2<15), то a = 1, b = mid
Заново mid = 3 x[mid] = 10 > p => a=1 b=3
Заново mid = 2 x[2] = 2 = p => Нашли
Программа (фрагмент)
a=1; b=n;
while (a<=b)
{mid = (a+b)/2;
if (x[mid] = = p) break;
if (x[mid]<p) a = mid+1; else b=mid;
}
if (x[mid] = = p) printf(“%i”, mid);
else printf(“такого элемента нет”);
Почему a присвоил 1? Номер первого элемента
—//— b —//— n? —//— последнего элемента
Бинарный поиск имеет количество операций O(log2n).
Если n=210=1024 элемента => О(10) (всего 10 просмотров)
Если n=220 => O(20)
Чем больше n, тем выгоднее использовать бинарный поиск.
Пример: В России 32 млн. => n=230 => 30 операций
Если массив хаотичен, то рассматриваем массив поэлементно. Существуют
блочные методы.
Методы сортировки.
Сортировка – процесс перестановки объектов заданной совокупности в
определенном порядке (возрастание, убывание).
Существует более 10 принципиально различных методов. Остальные похожи
более или менее.
 Метод выбора
6
 Метод обмена (метод пузырька)
 Метод вставки
 Метод Шелла
 Метод быстрой сортировки – будем проходить, когда пройдем тему
«рекурсия»
Значит, сортировать можем либо по возрастанию, либо по убыванию.
Метод выбора (по возрастанию)
Для этого в массиве, начиная с первого элемента до последнего, выбирается
наибольший элемент и ставится на последнее место, а последний – на место
наибольшего. Затем ищем наибольший элемент до предпоследнего элемента,
эта процедура повторяется.
Фрагмент программы:
for (k=1; k<=n-1; k++)
{m=1; //предполагаем, что 1-й элемент является максимальным
for (i=2; i<=n+1-k; i++)
if (a[i]>a[m]) m=1;
R=a[n+1-k]; a[n+1-k]=a[m]; a[m]=R;
}
a[n+1-k]=a[m];
a[m]=a[n+1-k]; Почему неправильно?
Почему n+k-1?
Подсчитаем количество операций.
количество циклов = (n-1)
для первого цикла: (n-1)*3
при втором цикле: (n-2)*3
…
(n-1): 1
Суммируем 1+2+…+(n-2)+(n-1) = n(n-1)/2 => O(n
2
)
Значит, если 1000 элементов => миллион операций
Самый быстрый метод O(nlog2n)
Если хотим сортировать по убыванию, что поменяется в программе?
Метод обмена (метод пузырька)
Двое нырнули в воду, кто больше выпустит пузырей? Тот кто больше.
7
Отсортируем по возрастанию. Идея состоит в последовательном
перемещении путем попарных перестановок наибольшего значения сначала
на место N-го элемента, затем (N-1)-го и т.д.
Количество проходов = (n-1)
Фрагмент программы.
for (k=1; k<=n-1; k++)
for (i=1; i<=n-k;i++)
 if (a[i]>a[i+1])
 {r=a[i]; a[i]=a[i+1]; a[i+1]=r;}
Операций O(n2
)
Что поменяется если хотим отсортировать по убыванию?
Метод вставки ((O(n2
))
Дана последовательность чисел a1, a2,…, an. Требуется отсортировать по
возрастанию. Пусть a1, a2,…, ai – упорядоченная последовательность, т.е.
a1≤a2≤…≤ai
.
Берется следующее число ai+1 и вставляется в последовательность так, чтобы
новая последовательность была также возрастающей.
Процесс производится до тех пор, пока все элементы от i+1 до n не будут
перебраны.